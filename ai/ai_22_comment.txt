from collections import deque

# Define the Graph class with its methods
class Graph:
    # Initialize the graph with an adjacency list representing the graph
    def __init__(self, adjacency_list):
        self.adjacency_list = adjacency_list

    # Retrieve the neighbors (edges) of a specific node
    def get_neighbors(self, v):
        return self.adjacency_list[v]

    # Define the heuristic function, h(n), which provides an estimated cost to the goal for each node
    def h(self, n):
        # Predefined heuristic values for different nodes
        H = {
            'A': 3,
            'B': 4,
            'C': 2,
            'D': 6,
            'G': 0,
            'S': 5
        }
        return H[n]

    # A* algorithm to find the shortest path from start_node to stop_node
    def a_star_algorithm(self, start_node, stop_node):
        open_list = set([start_node])  # Nodes yet to be evaluated
        closed_list = set([])  # Nodes already evaluated
        g = {}  # Stores the cost from start node to each node
        g[start_node] = 0  # Cost for the start node is 0
        parents = {}  # Keeps track of the parent nodes for path reconstruction
        parents[start_node] = start_node  # The parent of the start node is itself

        while len(open_list) > 0:
            n = None  # Variable to store the node with the lowest f(n)
            for v in open_list:
                # Select the node with the lowest f(n) = g(n) + h(n)
                if n is None or g[v] + self.h(v) < g[n] + self.h(n):
                    n = v
            if n is None:
                print('Path does not exist!')
                return None  # No valid path found

            if n == stop_node:
                # Reconstruct the path by tracing parent nodes
                reconst_path = []
                while parents[n] != n:
                    reconst_path.append(n)
                    n = parents[n]
                reconst_path.append(start_node)
                reconst_path.reverse()  # Reverse the path to start from the beginning
                print('Path found: {}'.format(reconst_path))
                return reconst_path  # Return the reconstructed path

            # Evaluate each neighbor of the current node n
            for (m, weight) in self.get_neighbors(n):
                if m not in open_list and m not in closed_list:
                    open_list.add(m)  # Add the neighbor to the open list
                    parents[m] = n  # Set current node as parent of the neighbor
                    g[m] = g[n] + weight  # Update cost for the neighbor

                else:
                    # If the new path to m is shorter, update it
                    if g[m] > g[n] + weight:
                        g[m] = g[n] + weight
                        parents[m] = n

                if m in closed_list:
                    # Move the node from closed list back to open list for re-evaluation
                    closed_list.remove(m)
                    open_list.add(m)

            open_list.remove(n)  # Move current node from open list to closed list
            closed_list.add(n)

        print('Path does not exist!')
        return None  # No valid path found

# Example adjacency list representing the graph
adjacency_list = {
    'A': [('B', 2), ('C', 1)],  # Node A is connected to B and C with respective weights
    'B': [('D', 5)],  # Node B is connected to D with weight 5
    'C': [('D', 3), ('G', 4)],  # Node C is connected to D and G
    'D': [('G', 2)],  # Node D is connected to G
    'S': [('A', 1), ('G', 10)]  # Node S is connected to A and G with respective weights
}

# Create a graph object using the adjacency list
graph1 = Graph(adjacency_list)

# Find the path from node 'S' to node 'G' using A* algorithm
graph1.a_star_algorithm('S', 'G')

# --- Second Part of Code (8-Puzzle Solver) ---

from copy import deepcopy
import numpy as np
import time

# Function to print the 3x3 puzzle in a grid format
def print_puzzle(puzzle):
    """Print the puzzle in a 3x3 grid format"""
    puzzle = np.array(puzzle).reshape(3, 3)  # Reshape the puzzle to 3x3 grid
    for row in puzzle:
        print(' '.join(map(str, row)))  # Print each row of the puzzle

# Function to reconstruct the solution path by following parent nodes
def bestsolution(state):
    bestsol = np.array([], int).reshape(-1, 9)  # Array to store the solution path
    count = len(state) - 1  # Start from the last state
    while count != -1:
        bestsol = np.insert(bestsol, 0, state[count]['puzzle'], 0)  # Insert puzzle at the beginning of the path
        count = (state[count]['parent'])  # Move to the parent state
    return bestsol

# Function to calculate the number of misplaced tiles between the current puzzle and the goal puzzle
def misplaced_tiles(puzzle, goal):
    mscost = np.sum(puzzle != goal) - 1  # Count the misplaced tiles (excluding the blank tile)
    return mscost if mscost > 0 else 0  # Return the number of misplaced tiles, ensuring it's at least 0

# Function to get the current coordinates of each tile in the puzzle
def coordinates(puzzle):
    pos = np.array(range(9))  # Initialize the positions of tiles (0 to 8)
    for p, q in enumerate(puzzle):
        pos[q] = p  # Update the position of each tile
    return pos

# Function to get the position of the blank tile (represented by 0)
def get_blank_position(puzzle):
    """Get the position of the blank (0) tile"""
    blank_pos = np.where(puzzle == 0)  # Locate the position of the blank tile
    return blank_pos[0].item()  # Return the position as an integer

# Main function to evaluate the misplaced tiles and find the solution using A* search
def evaluvate_misplaced(puzzle, goal):
    # Define the possible moves for the blank tile: up, down, left, and right
    dtype = [('move', 'U4'), ('position', 'O'), ('head', int)]
    steps = np.array([
        ('up', [0, 1, 2], -3),  # Move up (decrease index by 3)
        ('down', [6, 7, 8], 3),  # Move down (increase index by 3)
        ('left', [0, 3, 6], -1),  # Move left (decrease index by 1)
        ('right', [2, 5, 8], 1)  # Move right (increase index by 1)
    ], dtype=dtype)

    # Define the structured data types for state and priority queues
    dtstate = [('puzzle', list), ('parent', int), ('gn', int), ('hn', int)]
    costg = coordinates(goal)  # Coordinates of the goal puzzle
    parent = -1  # Initial parent is -1 (no parent)
    gn = 0  # Cost from the start state
    hn = misplaced_tiles(coordinates(puzzle), costg)  # Heuristic (misplaced tiles)
    state = np.array([(puzzle, parent, gn, hn)], dtstate)  # Initial state
    dtpriority = [('position', int), ('fn', int)]  # Priority queue data type
    priority = np.array([(0, hn)], dtpriority)  # Initial priority queue with the heuristic value

    # A* search loop to find the solution
    while len(priority) > 0:
        priority = np.sort(priority, kind='mergesort', order=['fn', 'position'])  # Sort the priority queue
        position, fn = priority[0]  # Get the node with the lowest f(n)
        priority = np.delete(priority, 0, 0)  # Remove the node from the queue
        puzzle, parent, gn, hn = state[position]  # Get the puzzle state and its details
        puzzle = np.array(puzzle)
        blank = get_blank_position(puzzle)  # Get the position of the blank tile
        gn = gn + 1  # Increment the cost for the next step

        # Try moving the blank tile in all four directions (up, down, left, right)
        for s in steps:
            if blank not in s['position']:  # Skip invalid moves (out of bounds)
                openstates = deepcopy(puzzle)  # Make a copy of the puzzle
                openstates[blank], openstates[blank + s['head']] = openstates[blank + s['head']], openstates[blank]  # Make the move
                if not (np.all(list(state['puzzle']) == openstates, 1)).any():  # Avoid revisiting the same state
                    hn = misplaced_tiles(coordinates(openstates), costg)  # Calculate new heuristic
                    q = np.array([(openstates.tolist(), position, gn, hn)], dtstate)  # Create new state
                    state = np.append(state, q, 0)  # Add new state to the list
                    fn = gn + hn  # Calculate f(n) = g(n) + h(n)
                    q = np.array([(len(state) - 1, fn)], dtpriority)  # Add the state to the priority queue
                    priority = np.append(priority, q, 0)

                # Check if the goal state is reached
                if np.array_equal(openstates, goal):
                    print('The 8 puzzle is solvable')
                    return state, len(priority)  # Return the solution path

        # If no solution found
        if len(priority) == 0:
            print('The 8 puzzle is not solvable')
            return None, 0

# Initial state and goal state for the 8-puzzle
puzzle = [2, 8, 3, 1, 6, 4, 7, 0, 5]  # Initial puzzle configuration
goal = [1, 2, 3, 8, 0, 4, 7, 6, 5]  # Goal puzzle configuration

# Run the evaluation to solve the puzzle using A* search
result = evaluvate_misplaced(puzzle, goal)
if result[0] is not None:
    state, visited = result  # Retrieve the solution path and visited nodes
    bestpath = bestsolution(state)  # Get the solution path
    for path in bestpath:
        print_puzzle(path)  # Print each puzzle state in the solution path
        print()
    totalmoves = len(bestpath) - 1  # Calculate the number of moves
    print('Steps to reach goal:', totalmoves)  # Print the number of steps
    print('Total nodes visited:', len(state) - visited)  # Print the total nodes visited
