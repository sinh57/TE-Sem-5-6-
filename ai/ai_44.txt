def is_safe(board, row, col, n):
    for i in range(row):
        if board[i] == col or \
           board[i] - i == col - row or \
           board[i] + i == col + row:
            return False
    return True

def solve_n_queens(n, row=0, board=[], solutions=[]):
    if row == n:
        solutions.append(board[:])
        return
    for col in range(n):
        if is_safe(board, row, col, n):
            board.append(col)
            solve_n_queens(n, row + 1, board, solutions)
            board.pop()

n = 4
solutions = []
solve_n_queens(n, 0, [], solutions)
print(f"Solutions for {n}-Queens: {solutions}")

#################################################################
def is_safe(board, row, col):
    # Check if the queen can be placed safely
    for i in range(row):
        if board[i] == col or \
           board[i] - i == col - row or \
           board[i] + i == col + row:
            return False
    return True

def solve_n_queens(n, row, board, solutions):
    if row == n:
        solutions.append(board[:])
        return
    for col in range(n):
        if is_safe(board, row, col):
            board.append(col)
            solve_n_queens(n, row + 1, board, solutions)
            board.pop()  # backtrack

def print_solutions(solutions, n):
    for i, sol in enumerate(solutions, 1):
        print(f"Solution {i}:")
        for col in sol:
            row = ["."] * n
            row[col] = "Q"
            print(" ".join(row))
        print()

# Main program
try:
    n = int(input("Enter number of queens: "))
    if n < 1:
        print("Please enter a positive number.")
    else:
        solutions = []
        solve_n_queens(n, 0, [], solutions)
        print(f"\nTotal solutions for {n}-Queens: {len(solutions)}\n")
        print_solutions(solutions, n)
except ValueError:
    print("Please enter a valid integer.")

